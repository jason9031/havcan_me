//
// File generated by HDevelop for HALCON/.NET (C#) Version 18.11.1.1
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
    public HDevelopExport()
    {
        // Default settings used in HDevelop
        HOperatorSet.SetSystem("width", 512);
        HOperatorSet.SetSystem("height", 512);
        if (HalconAPI.isWindows)
            HOperatorSet.SetSystem("use_window_thread", "true");
        action();
    }
#endif

    // Procedures 
    // External procedures 
    // Chapter: Develop
    // Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
    public void dev_open_window_fit_image(HObject ho_Image, HTuple hv_Row, HTuple hv_Column,
        HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
    {




        // Local iconic variables 

        // Local control variables 

        HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
        HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
        HTuple hv_ResizeFactor = new HTuple(), hv_ImageWidth = new HTuple();
        HTuple hv_ImageHeight = new HTuple(), hv_TempWidth = new HTuple();
        HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
        HTuple hv_WindowHeight = new HTuple();
        // Initialize local and output iconic variables 
        hv_WindowHandle = new HTuple();
        try
        {
            //This procedure opens a new graphics window and adjusts the size
            //such that it fits into the limits specified by WidthLimit
            //and HeightLimit, but also maintains the correct image aspect ratio.
            //
            //If it is impossible to match the minimum and maximum extent requirements
            //at the same time (f.e. if the image is very long but narrow),
            //the maximum value gets a higher priority,
            //
            //Parse input tuple WidthLimit
            if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
            {
                hv_MinWidth.Dispose();
                hv_MinWidth = 500;
                hv_MaxWidth.Dispose();
                hv_MaxWidth = 800;
            }
            else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                1))) != 0)
            {
                hv_MinWidth.Dispose();
                hv_MinWidth = 0;
                hv_MaxWidth.Dispose();
                hv_MaxWidth = new HTuple(hv_WidthLimit);
            }
            else
            {
                hv_MinWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MinWidth = hv_WidthLimit.TupleSelect(
                        0);
                }
                hv_MaxWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxWidth = hv_WidthLimit.TupleSelect(
                        1);
                }
            }
            //Parse input tuple HeightLimit
            if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
            {
                hv_MinHeight.Dispose();
                hv_MinHeight = 400;
                hv_MaxHeight.Dispose();
                hv_MaxHeight = 600;
            }
            else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                1))) != 0)
            {
                hv_MinHeight.Dispose();
                hv_MinHeight = 0;
                hv_MaxHeight.Dispose();
                hv_MaxHeight = new HTuple(hv_HeightLimit);
            }
            else
            {
                hv_MinHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MinHeight = hv_HeightLimit.TupleSelect(
                        0);
                }
                hv_MaxHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxHeight = hv_HeightLimit.TupleSelect(
                        1);
                }
            }
            //
            //Test, if window size has to be changed.
            hv_ResizeFactor.Dispose();
            hv_ResizeFactor = 1;
            hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
            HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
            //First, expand window to the minimum extents (if necessary).
            if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                hv_ImageHeight)))) != 0)
            {
                hv_ResizeFactor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                        ) / hv_ImageWidth)).TupleConcat((hv_MinHeight.TupleReal()) / hv_ImageHeight))).TupleMax()
                        ;
                }
            }
            hv_TempWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_TempWidth = hv_ImageWidth * hv_ResizeFactor;
            }
            hv_TempHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_TempHeight = hv_ImageHeight * hv_ResizeFactor;
            }
            //Then, shrink window to maximum extents (if necessary).
            if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                hv_TempHeight)))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                            ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                            );
                        hv_ResizeFactor.Dispose();
                        hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                    }
                }
            }
            hv_WindowWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_WindowWidth = hv_ImageWidth * hv_ResizeFactor;
            }
            hv_WindowHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_WindowHeight = hv_ImageHeight * hv_ResizeFactor;
            }
            //Resize window
            HOperatorSet.SetWindowAttr("background_color", "black");
            HOperatorSet.OpenWindow(hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandle);
            HDevWindowStack.Push(hv_WindowHandle);
            if (HDevWindowStack.IsOpen())
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight - 1,
                        hv_ImageWidth - 1);
                }
            }

            hv_MinWidth.Dispose();
            hv_MaxWidth.Dispose();
            hv_MinHeight.Dispose();
            hv_MaxHeight.Dispose();
            hv_ResizeFactor.Dispose();
            hv_ImageWidth.Dispose();
            hv_ImageHeight.Dispose();
            hv_TempWidth.Dispose();
            hv_TempHeight.Dispose();
            hv_WindowWidth.Dispose();
            hv_WindowHeight.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_MinWidth.Dispose();
            hv_MaxWidth.Dispose();
            hv_MinHeight.Dispose();
            hv_MaxHeight.Dispose();
            hv_ResizeFactor.Dispose();
            hv_ImageWidth.Dispose();
            hv_ImageHeight.Dispose();
            hv_TempWidth.Dispose();
            hv_TempHeight.Dispose();
            hv_WindowWidth.Dispose();
            hv_WindowHeight.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure writes a text message. 
    public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_GenParamName = new HTuple(), hv_GenParamValue = new HTuple();
        HTuple hv_Color_COPY_INP_TMP = new HTuple(hv_Color);
        HTuple hv_Column_COPY_INP_TMP = new HTuple(hv_Column);
        HTuple hv_CoordSystem_COPY_INP_TMP = new HTuple(hv_CoordSystem);
        HTuple hv_Row_COPY_INP_TMP = new HTuple(hv_Row);

        // Initialize local and output iconic variables 
        try
        {
            //This procedure displays text in a graphics window.
            //
            //Input parameters:
            //WindowHandle: The WindowHandle of the graphics window, where
            //   the message should be displayed
            //String: A tuple of strings containing the text message to be displayed
            //CoordSystem: If set to 'window', the text position is given
            //   with respect to the window coordinate system.
            //   If set to 'image', image coordinates are used.
            //   (This may be useful in zoomed images.)
            //Row: The row coordinate of the desired text position
            //   A tuple of values is allowed to display text at different
            //   positions.
            //Column: The column coordinate of the desired text position
            //   A tuple of values is allowed to display text at different
            //   positions.
            //Color: defines the color of the text as string.
            //   If set to [], '' or 'auto' the currently set color is used.
            //   If a tuple of strings is passed, the colors are used cyclically...
            //   - if |Row| == |Column| == 1: for each new textline
            //   = else for each text position.
            //Box: If Box[0] is set to 'true', the text is written within an orange box.
            //     If set to' false', no box is displayed.
            //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
            //       the text is written in a box of that color.
            //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
            //       'true' -> display a shadow in a default color
            //       'false' -> display no shadow
            //       otherwise -> use given string as color string for the shadow color
            //
            //It is possible to display multiple text strings in a single call.
            //In this case, some restrictions apply:
            //- Multiple text positions can be defined by specifying a tuple
            //  with multiple Row and/or Column coordinates, i.e.:
            //  - |Row| == n, |Column| == n
            //  - |Row| == n, |Column| == 1
            //  - |Row| == 1, |Column| == n
            //- If |Row| == |Column| == 1,
            //  each element of String is display in a new textline.
            //- If multiple positions or specified, the number of Strings
            //  must match the number of positions, i.e.:
            //  - Either |String| == n (each string is displayed at the
            //                          corresponding position),
            //  - or     |String| == 1 (The string is displayed n times).
            //
            //
            //Convert the parameters for disp_text.
            if ((int)((new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
            {

                hv_Color_COPY_INP_TMP.Dispose();
                hv_Column_COPY_INP_TMP.Dispose();
                hv_CoordSystem_COPY_INP_TMP.Dispose();
                hv_Row_COPY_INP_TMP.Dispose();
                hv_GenParamName.Dispose();
                hv_GenParamValue.Dispose();

                return;
            }
            if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Row_COPY_INP_TMP.Dispose();
                hv_Row_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Column_COPY_INP_TMP.Dispose();
                hv_Column_COPY_INP_TMP = 12;
            }
            //
            //Convert the parameter Box to generic parameters.
            hv_GenParamName.Dispose();
            hv_GenParamName = new HTuple();
            hv_GenParamValue.Dispose();
            hv_GenParamValue = new HTuple();
            if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
            {
                if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
                {
                    //Display no box
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                                "box");
                            hv_GenParamName.Dispose();
                            hv_GenParamName = ExpTmpLocalVar_GenParamName;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
                                "false");
                            hv_GenParamValue.Dispose();
                            hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                        }
                    }
                }
                else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual(
                    "true"))) != 0)
                {
                    //Set a color other than the default.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                                "box_color");
                            hv_GenParamName.Dispose();
                            hv_GenParamName = ExpTmpLocalVar_GenParamName;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
                                hv_Box.TupleSelect(0));
                            hv_GenParamValue.Dispose();
                            hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                        }
                    }
                }
            }
            if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
            {
                if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
                {
                    //Display no shadow.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                                "shadow");
                            hv_GenParamName.Dispose();
                            hv_GenParamName = ExpTmpLocalVar_GenParamName;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
                                "false");
                            hv_GenParamValue.Dispose();
                            hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                        }
                    }
                }
                else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual(
                    "true"))) != 0)
                {
                    //Set a shadow color other than the default.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                                "shadow_color");
                            hv_GenParamName.Dispose();
                            hv_GenParamName = ExpTmpLocalVar_GenParamName;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
                                hv_Box.TupleSelect(1));
                            hv_GenParamValue.Dispose();
                            hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                        }
                    }
                }
            }
            //Restore default CoordSystem behavior.
            if ((int)(new HTuple(hv_CoordSystem_COPY_INP_TMP.TupleNotEqual("window"))) != 0)
            {
                hv_CoordSystem_COPY_INP_TMP.Dispose();
                hv_CoordSystem_COPY_INP_TMP = "image";
            }
            //
            if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
            {
                //disp_text does not accept an empty string for Color.
                hv_Color_COPY_INP_TMP.Dispose();
                hv_Color_COPY_INP_TMP = new HTuple();
            }
            //
            HOperatorSet.DispText(hv_WindowHandle, hv_String, hv_CoordSystem_COPY_INP_TMP,
                hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName,
                hv_GenParamValue);

            hv_Color_COPY_INP_TMP.Dispose();
            hv_Column_COPY_INP_TMP.Dispose();
            hv_CoordSystem_COPY_INP_TMP.Dispose();
            hv_Row_COPY_INP_TMP.Dispose();
            hv_GenParamName.Dispose();
            hv_GenParamValue.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Color_COPY_INP_TMP.Dispose();
            hv_Column_COPY_INP_TMP.Dispose();
            hv_CoordSystem_COPY_INP_TMP.Dispose();
            hv_Row_COPY_INP_TMP.Dispose();
            hv_GenParamName.Dispose();
            hv_GenParamValue.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Graphics / Text
    // Short Description: Set font independent of OS 
    public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
        HTuple hv_Bold, HTuple hv_Slant)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
        HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
        HTuple hv_Indices = new HTuple();
        HTuple hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
        HTuple hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

        // Initialize local and output iconic variables 
        try
        {
            //This procedure sets the text font of the current window with
            //the specified attributes.
            //
            //Input parameters:
            //WindowHandle: The graphics window for which the font will be set
            //Size: The font size. If Size=-1, the default of 16 is used.
            //Bold: If set to 'true', a bold font is used
            //Slant: If set to 'true', a slanted font is used
            //
            hv_OS.Dispose();
            HOperatorSet.GetSystem("operating_system", out hv_OS);
            if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
            {
                hv_Size_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP = 16;
            }
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                //Restore previous behaviour
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Size = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt()
                            ;
                        hv_Size_COPY_INP_TMP.Dispose();
                        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                    }
                }
            }
            else
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
                            ;
                        hv_Size_COPY_INP_TMP.Dispose();
                        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                    }
                }
            }
            if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Courier";
                hv_Fonts[1] = "Courier 10 Pitch";
                hv_Fonts[2] = "Courier New";
                hv_Fonts[3] = "CourierNew";
                hv_Fonts[4] = "Liberation Mono";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Consolas";
                hv_Fonts[1] = "Menlo";
                hv_Fonts[2] = "Courier";
                hv_Fonts[3] = "Courier 10 Pitch";
                hv_Fonts[4] = "FreeMono";
                hv_Fonts[5] = "Liberation Mono";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Luxi Sans";
                hv_Fonts[1] = "DejaVu Sans";
                hv_Fonts[2] = "FreeSans";
                hv_Fonts[3] = "Arial";
                hv_Fonts[4] = "Liberation Sans";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Times New Roman";
                hv_Fonts[1] = "Luxi Serif";
                hv_Fonts[2] = "DejaVu Serif";
                hv_Fonts[3] = "FreeSerif";
                hv_Fonts[4] = "Utopia";
                hv_Fonts[5] = "Liberation Serif";
            }
            else
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
            }
            hv_Style.Dispose();
            hv_Style = "";
            if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Style = hv_Style + "Bold";
                        hv_Style.Dispose();
                        hv_Style = ExpTmpLocalVar_Style;
                    }
                }
            }
            else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "Wrong value of control parameter Bold";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Style = hv_Style + "Italic";
                        hv_Style.Dispose();
                        hv_Style = ExpTmpLocalVar_Style;
                    }
                }
            }
            else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "Wrong value of control parameter Slant";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
            {
                hv_Style.Dispose();
                hv_Style = "Normal";
            }
            hv_AvailableFonts.Dispose();
            HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
            hv_Font_COPY_INP_TMP.Dispose();
            hv_Font_COPY_INP_TMP = "";
            for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
            {
                hv_Indices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Indices = hv_AvailableFonts.TupleFind(
                        hv_Fonts.TupleSelect(hv_Fdx));
                }
                if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                    {
                        hv_Font_COPY_INP_TMP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                                hv_Fdx);
                        }
                        break;
                    }
                }
            }
            if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
            {
                throw new HalconException("Wrong value of control parameter Font");
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
                    hv_Font_COPY_INP_TMP.Dispose();
                    hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
                }
            }
            HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

            hv_Font_COPY_INP_TMP.Dispose();
            hv_Size_COPY_INP_TMP.Dispose();
            hv_OS.Dispose();
            hv_Fonts.Dispose();
            hv_Style.Dispose();
            hv_Exception.Dispose();
            hv_AvailableFonts.Dispose();
            hv_Fdx.Dispose();
            hv_Indices.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Font_COPY_INP_TMP.Dispose();
            hv_Size_COPY_INP_TMP.Dispose();
            hv_OS.Dispose();
            hv_Fonts.Dispose();
            hv_Style.Dispose();
            hv_Exception.Dispose();
            hv_AvailableFonts.Dispose();
            hv_Fdx.Dispose();
            hv_Indices.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Local procedures 
    public void CheckNetBreak(HObject ho_Image, out HObject ho_ImageOut, out HObject ho_ImageMean,
        out HObject ho_RegionDynThresh, out HObject ho_ConnectedRegions, out HObject ho_ErrorRegions,
        out HTuple hv_Width, out HTuple hv_Height, out HTuple hv_WindowHandle, out HTuple hv_NumErrors)
    {



        // Local iconic variables 
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ImageOut);
        HOperatorSet.GenEmptyObj(out ho_ImageMean);
        HOperatorSet.GenEmptyObj(out ho_RegionDynThresh);
        HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
        HOperatorSet.GenEmptyObj(out ho_ErrorRegions);
        hv_Width = new HTuple();
        hv_Height = new HTuple();
        hv_WindowHandle = new HTuple();
        hv_NumErrors = new HTuple();
        ho_ImageOut.Dispose();
        ho_ImageOut = new HObject(ho_Image);
        //获取图像大小
        hv_Width.Dispose(); hv_Height.Dispose();
        HOperatorSet.GetImageSize(ho_ImageOut, out hv_Width, out hv_Height);

        //创建一个新窗口
        hv_WindowHandle.Dispose();
        dev_open_window_fit_image(ho_ImageOut, 0, 0, hv_Width, hv_Height, out hv_WindowHandle);


        //设置字体信息:字体大小为16，字体为mono,粗体，斜体
        set_display_font(hv_WindowHandle, 18, "mono", "true", "false");

        //设置区域的填充方式
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
        }

        //设置线宽度
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
        }


        //*for J := 1 to 14 by 1
        //读取一张图像
        //read_image (ImageOut, 'plastic_mesh/plastic_mesh_' + J$'02')

        //均值滤波
        ho_ImageMean.Dispose();
        HOperatorSet.MeanImage(ho_ImageOut, out ho_ImageMean, 49, 49);

        //局部阈值分割图像
        ho_RegionDynThresh.Dispose();
        HOperatorSet.DynThreshold(ho_ImageOut, ho_ImageMean, out ho_RegionDynThresh,
            5, "dark");

        //对分割后的区域进行连通处理
        ho_ConnectedRegions.Dispose();
        HOperatorSet.Connection(ho_RegionDynThresh, out ho_ConnectedRegions);

        //过滤出缺陷网孔区域
        ho_ErrorRegions.Dispose();
        HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_ErrorRegions, "area", "and",
            500, 99999);

        //统计出缺陷网孔的数目
        hv_NumErrors.Dispose();
        HOperatorSet.CountObj(ho_ErrorRegions, out hv_NumErrors);

        //显示图像
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.DispObj(ho_ImageOut, HDevWindowStack.GetActive());
        }

        //设置对象的显示颜色
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
        }

        //显示缺陷网孔
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.DispObj(ho_ErrorRegions, HDevWindowStack.GetActive());
        }

        if ((int)(new HTuple(hv_NumErrors.TupleGreater(0))) != 0)
        {
            //显示产品NG
            disp_message(hv_WindowHandle, "Mesh not OK", "window", 24, 12, "black", "true");
        }
        else
        {
            //显示产品OK
            disp_message(hv_WindowHandle, "Mesh OK", "window", 24, 12, "black", "true");
        }


        return;
    }

#if !NO_EXPORT_MAIN
    // Main procedure 
    private void action()
    {


        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_Image = null, ho_ImageMean, ho_RegionDynThresh;
        HObject ho_ConnectedRegions, ho_ErrorRegions;

        // Local control variables 

        HTuple hv_AcqHandle = new HTuple(), hv_Width = new HTuple();
        HTuple hv_Height = new HTuple(), hv_WindowHandle = new HTuple();
        HTuple hv_NumErrors = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);
        HOperatorSet.GenEmptyObj(out ho_ImageMean);
        HOperatorSet.GenEmptyObj(out ho_RegionDynThresh);
        HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
        HOperatorSet.GenEmptyObj(out ho_ErrorRegions);
        try
        {

            //Image Acquisition 02: Code generated by Image Acquisition 02
            hv_AcqHandle.Dispose();
            HOperatorSet.OpenFramegrabber("DirectShow", 1, 1, 0, 0, 0, 0, "default", 8,
                "rgb", -1, "false", "default", "[0]", 0, -1, out hv_AcqHandle);
            HOperatorSet.GrabImageStart(hv_AcqHandle, -1);
            //while (true)
            ho_Image.Dispose();
            HOperatorSet.GrabImageAsync(out ho_Image, hv_AcqHandle, -1);
            //Image Acquisition 02: Do something
            //endwhile
            HOperatorSet.CloseFramegrabber(hv_AcqHandle);




            //关闭程序计数器,图形变量更新,窗口图形更新
            // dev_update_window(...); only in hdevelop

            //读取一张图像
            //read_image (Image, 'plastic_mesh/plastic_mesh_01')

            //关闭打开的窗口
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
            }

            {
                HObject ExpTmpOutVar_0; ho_ImageMean.Dispose(); ho_RegionDynThresh.Dispose(); ho_ConnectedRegions.Dispose(); ho_ErrorRegions.Dispose(); hv_Width.Dispose(); hv_Height.Dispose(); hv_WindowHandle.Dispose(); hv_NumErrors.Dispose();
                CheckNetBreak(ho_Image, out ExpTmpOutVar_0, out ho_ImageMean, out ho_RegionDynThresh,
                    out ho_ConnectedRegions, out ho_ErrorRegions, out hv_Width, out hv_Height,
                    out hv_WindowHandle, out hv_NumErrors);
                ho_Image.Dispose();
                ho_Image = ExpTmpOutVar_0;
            }

            // stop(...); only in hdevelop

            //*endfor
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Image.Dispose();
            ho_ImageMean.Dispose();
            ho_RegionDynThresh.Dispose();
            ho_ConnectedRegions.Dispose();
            ho_ErrorRegions.Dispose();

            hv_AcqHandle.Dispose();
            hv_Width.Dispose();
            hv_Height.Dispose();
            hv_WindowHandle.Dispose();
            hv_NumErrors.Dispose();

            throw HDevExpDefaultException;
        }
        ho_Image.Dispose();
        ho_ImageMean.Dispose();
        ho_RegionDynThresh.Dispose();
        ho_ConnectedRegions.Dispose();
        ho_ErrorRegions.Dispose();

        hv_AcqHandle.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_WindowHandle.Dispose();
        hv_NumErrors.Dispose();

    }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
    static void Mai12n(string[] args)
    {
        new HDevelopExport();
    }
}
#endif

